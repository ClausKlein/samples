diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8ed2c91..95b235c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -18,6 +18,14 @@ set(CMAKE_CXX_STANDARD_REQUIRED ON)
 set(CMAKE_CXX_EXTENSIONS OFF)
 set(CMAKE_CXX_FLAGS -Wpedantic)
 
+if(UNIX)
+    set(CMAKE_CXX_FLAGS "-Wpedantic -Werrors")
+    find_library(PTHREAD_LIB pthread REQUIRED)
+endif()
+
+# see /usr/local/lib/cmake/gsl-lite/gsl-lite-targets.cmake
+find_package(gsl-lite REQUIRED)
+
 enable_testing()
 
 set(c_sources
@@ -33,7 +41,7 @@ set(cxx_sources
     ClonableBase.cpp
     classOutput.cpp
     clone.cpp
-    NonCopyable.cpp
+    #BOOST needed! NonCopyable.cpp
     DoNotSlice.cpp
     CloneShapes.cpp
     #!NO! collate.cpp
@@ -83,14 +91,14 @@ set(cxx_sources
     use_span.cpp
     vector.cpp
     vokable2.cpp
-    volatile.cpp
+    #FIXME volatile.cpp
 )
 
 foreach(source ${cxx_sources})
     string(REGEX REPLACE "\.cpp$" "" program ${source})
     add_executable(${program} ${program}.cpp)
     set_target_properties(${program} PROPERTIES CXX_STANDARD 17)
-    # target_link_libraries(${program} ${EXTRA_LIBS})
+    target_link_libraries(${program} PRIVATE gsl::gsl-lite ${PTHREAD_LIB})
     add_test(NAME ${program} COMMAND ${program})
 endforeach()
 
diff --git a/ClonableBase.cpp b/ClonableBase.cpp
index 5cdc55d..2112948 100644
--- a/ClonableBase.cpp
+++ b/ClonableBase.cpp
@@ -5,7 +5,7 @@
 // =delete them all
 
 #include <cassert>
-#include <gsl/pointers>
+#include <gsl/gsl>
 #include <memory> // NOTE: make_unique<>! CK
 #include <string>
 
diff --git a/EreaseRemoveIdiom.cpp b/EreaseRemoveIdiom.cpp
index d2f72d5..e7022ba 100644
--- a/EreaseRemoveIdiom.cpp
+++ b/EreaseRemoveIdiom.cpp
@@ -2,6 +2,7 @@
 
 #include <algorithm> // remove and remove_if
 #include <iostream>
+#include <iterator>
 #include <vector> // the general-purpose vector container
 
 bool is_odd(int i) { return (i % 2) != 0; }
diff --git a/clone.cpp b/clone.cpp
index 4c29860..c4a7d57 100644
--- a/clone.cpp
+++ b/clone.cpp
@@ -12,13 +12,13 @@
 // return type). Example
 
 #include <cassert>
-#include <gsl/pointers>
+#include <gsl/gsl>
 
 class B
 {
 public:
     B() = default;
-    virtual ~B() = 0;
+    virtual ~B() = default;
 
     virtual gsl::owner<B *> clone() const = 0;
 
@@ -30,7 +30,7 @@ class D : public B
 {
 public:
     D() = default;
-    virtual ~D() {}
+    ~D() override {}
 
     gsl::owner<D *> clone() const override
     {
@@ -51,9 +51,7 @@ public:
 
 int main()
 {
-#if 0
     D d1;
     auto d2 = d1.clone();
     // TODO assert (*d2 == d1);
-#endif
 }
diff --git a/unordered_set.cpp b/unordered_set.cpp
index 5e3c418..f61bba1 100644
--- a/unordered_set.cpp
+++ b/unordered_set.cpp
@@ -1,5 +1,6 @@
 #include <algorithm> // copy_if and remove_if
 #include <iostream>
+#include <iterator>
 #include <numeric> // iota
 
 #if defined(__cplusplus) && __cplusplus == 201103L
diff --git a/use_span.cpp b/use_span.cpp
index 7fee039..703774d 100644
--- a/use_span.cpp
+++ b/use_span.cpp
@@ -1,9 +1,11 @@
 // A span is a non-owning view over a contiguous sequence of objects, the
 // storage of which is owned by some other object.
 
-#include <array> // C++11
 // TODO #include <span>  // C++20
 
+#include <iostream>
+#include <array> // C++11
+
 #include <gsl/gsl> // C++14
 using gsl::at;
 using gsl::span;
@@ -17,7 +19,8 @@ void use(int *ptr, int value) { *ptr = value; }
 void f1a()
 {
     int arr[COUNT];
-    span<int, COUNT> av = arr;
+    span<int, COUNT> av = arr;   // C++20
+    //FIXME span<int> av = arr;
     int i = 0;
     for (auto &e : av)
         e = i++;
@@ -27,9 +30,11 @@ void f1a()
 void f2()
 {
     int arr[COUNT];
-    span<int, COUNT> av = arr;
-    for (int i = 0; i < COUNT; ++i) {
-        at(arr, i) = i;
+    span<int, COUNT> av = arr;   // C++20
+    //FIXME span<int> av = arr;
+    for (int i = 0; i <= av.size(); ++i) {
+        //FIXME at(arr, i) = i;
+        av[i] = i;
     }
 }
 
@@ -59,5 +64,11 @@ void f(span<int> a)
 int main()
 {
     std::array<int, COUNT> a{{1, 2, 3, 4, 5, 6}};
-    f(a);
+
+    try {
+        f(a);
+        f2();
+    } catch (std::exception &e) {
+        std::cout << e.what() << std::endl;
+    }
 }
